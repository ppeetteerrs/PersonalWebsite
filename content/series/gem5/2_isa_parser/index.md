---
title: gem5 Deep Dive â€“ ISA Parser (Part 2)
date: 2020-10-02
summary: In this blog post I will be going through the gem5 ISA parser mechanism and components.
categories:
  - Computer Architecture
  - Computer Engineering
tags:
  - gem5
  - huawei
type: book
weight: 20
---

# 1 Overview

The gem5 ISA Parser is probably one of the modules that very few people will tinker with, because ISA support is typically provided by the respective vendors (mainly Arm). However, since RISCV is an open-source ISA, there is no harm learning about its <a href="https://carrv.github.io/2017/papers/roelke-risc5-carrv2017.pdf" data-type="URL" data-id="https://carrv.github.io/2017/papers/roelke-risc5-carrv2017.pdf">implementation</a> in gem5.

# 2 The ISA-CPU Interface

The gem5 ISA DSL is designed to decouple ISA implementation from CPU modelling. The ISA DSL is a **templating language** used to generate a **parser** in C++. Before delving into the nitty gritty of the DSL, it is crucial to understand the interface between the CPU and the ISA.

## 2.1 ISA

<div class="wp-block-jetpack-markdown">
  <p>
    The purpose of the C++ code generated by the ISA parser (`isa_parser.py`) is to **map** each `uint64_t` machine instruction into a `StaticInst` object.
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <p>
    There are two main parts to the generated code: **decode** and **execute**, found under `build/RISCV/arch/riscv/generated`.
  </p>
</div>

### 2.1.1 Decode Files

<div class="wp-block-jetpack-markdown">
  <p>
    The decode files combine together to define a `Decoder` object under the `TheISA` namespace (mapped to `RiscvISA` through env variables). The files include:
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <ul>
    <li>
      `decode-method.cc.inc`: defines `Decoder::decodeInst(machInst)` which invokes a **different** `StaticInst` constructor for each unique type of 64-bit `machInst`
    </li>
    <li>
      `decoder-g.cc/hh.inc`: includes and headers
    </li>
    <li>
      `decoder-ns.cc/hh.inc`: defines all the `StaticInst` children class constructors (one for each type of `machInst`), often involves setting flags and register IDs
    </li>
  </ul>
</div>

### 2.1.2 Execute Files

<div class="wp-block-jetpack-markdown">
  <p>
    The execute files define the virtual methods of `StaticInst` for each type of `machInst`. Execute files include:
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <ul>
    <li>
      `exec-g.cc.inc`: includes and headers
    </li>
    <li>
      `exec-ns.cc.inc`: definition of `StaticInst` virtual methods
    </li>
  </ul>
</div>

### 2.1.3 StaticInst Interface

<div class="wp-block-jetpack-markdown">
  <p>
    A `StaticInst` object exposes four main functions: `execute` (execute a non-memory instruction), `initiateAcc` (initiate memory access), `completeAcc` (complete memory access) and `advancePC`. These functions can then be called by the CPU at the appropriate stages of the pipeline.
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <p>
    A `StaticInst` object also comes with a host of flags such as `isMemRef`, `isAtomic`, `isFloating` and OpClass in order to help the CPU determine how to handle the instruction (e.g. send to different queues / functional unit pipelines).
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <p>
    In addition, RISCV extends its own `StaticInst` classes (`RiscvStaticInst`, `RiscvMacroInst`, `RiscvMicroInst`) that define some common methods such as `advancePC`. The relevant source codes are shown below:
  </p>
</div>

<div class="wp-block-ub-tabbed-content wp-block-ub-tabbed-content-holder wp-block-ub-tabbed-content-horizontal-holder-mobile wp-block-ub-tabbed-content-horizontal-holder-tablet" id="ub-tabbed-content-263a5183-4c97-497a-ac81-0e72540782f6">
  <div role="tablist" class="wp-block-ub-tabbed-content-tab-holder  horizontal-tab-width-mobile horizontal-tab-width-tablet">
    <div class="wp-block-ub-tabbed-content-tabs-title wp-block-ub-tabbed-content-tabs-title-mobile-horizontal-tab wp-block-ub-tabbed-content-tabs-title-tablet-horizontal-tab">
      <div role="tab" id="ub-tabbed-content-263a5183-4c97-497a-ac81-0e72540782f6-tab-0" aria-controls="ub-tabbed-content-263a5183-4c97-497a-ac81-0e72540782f6-panel-0" aria-selected="false" class = "wp-block-ub-tabbed-content-tab-title-wrap"> 
      
      <div class="wp-block-ub-tabbed-content-tab-title">
        StaticInst
      </div>
    </div><div role="tab" id="ub-tabbed-content-263a5183-4c97-497a-ac81-0e72540782f6-tab-1" aria-controls="ub-tabbed-content-263a5183-4c97-497a-ac81-0e72540782f6-panel-1" aria-selected="false" class = "wp-block-ub-tabbed-content-tab-title-wrap"> 
    
    <div class="wp-block-ub-tabbed-content-tab-title">
      RiscvStaticInst
    </div>
  </div><div role="tab" id="ub-tabbed-content-263a5183-4c97-497a-ac81-0e72540782f6-tab-2" aria-controls="ub-tabbed-content-263a5183-4c97-497a-ac81-0e72540782f6-panel-2" aria-selected="false" class = "wp-block-ub-tabbed-content-tab-title-wrap"> 
  
  <div class="wp-block-ub-tabbed-content-tab-title">
    <em>RiscvMacroInst</em>
  </div>
</div><div role="tab" id="ub-tabbed-content-263a5183-4c97-497a-ac81-0e72540782f6-tab-3" aria-controls="ub-tabbed-content-263a5183-4c97-497a-ac81-0e72540782f6-panel-3" aria-selected="true" class = "wp-block-ub-tabbed-content-tab-title-wrap active">

<div class="wp-block-ub-tabbed-content-tab-title">
  <em>RiscvMicroInst</em>
</div></div></div></div>

<div class="wp-block-ub-tabbed-content-tabs-content ">
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap ub-hide"
        id="ub-tabbed-content--panel-0" aria-labelledby="ub-tabbed-content--tab-0">
    <pre class="wp-block-code"><code>// build/RISCV/cpu/static_inst.hh
class StaticInst : public RefCounted, public StaticInstFlags {
 public:
  // Execute non-memory instruction
  virtual Fault execute(ExecContext *xc, Trace::InstRecord *traceData);

// Initiate memory access
virtual Fault initiateAcc(ExecContext *xc, Trace::InstRecord *traceData);

// Complete memory access
virtual Fault completeAcc(Packet *pkt, ExecContext *xc, Trace::InstRecord \*traceData);

// Advance PC State
virtual void advancePC(TheISA::PCState &pcState);

// PC-relative branch target address
virtual TheISA::PCState branchTarget(const TheISA::PCState &pc);

// Indirect branch target address
virtual TheISA::PCState branchTarget(ThreadContext \*tc);

// Other functions
bool hasBranchTarget(const TheISA::PCState &pc, ThreadContext \*tc,
TheISA::PCState &tgt);

virtual StaticInstPtr fetchMicroop(MicroPC upc);

public:
// Register count
int8_t numSrcRegs();
int8_t numDestRegs();
int8_t numFPDestRegs();
int8_t numIntDestRegs();
int8_t numVecDestRegs();
int8_t numVecElemDestRegs();
int8_t numVecPredDestRegs();
int8_t numCCDestRegs();

// Flags ==> determine what method to call at each pipeline stage etc.
bool isNop();
bool isMemRef();
bool isLoad();
bool isStore();
bool isAtomic();
bool isStoreConditional();
bool isInstPrefetch();
bool isDataPrefetch();
bool isPrefetch();
bool isInteger();
bool isFloating();
bool isVector();
bool isCC();
bool isControl();
bool isCall();
bool isReturn();
bool isDirectCtrl();
bool isIndirectCtrl();
bool isCondCtrl();
bool isUncondCtrl();
bool isCondDelaySlot();
bool isThreadSync();
bool isSerializing();
bool isSerializeBefore();
bool isSerializeAfter();
bool isSquashAfter();
bool isMemBarrier();
bool isWriteBarrier();
bool isNonSpeculative();
bool isQuiesce();
bool isIprAccess();
bool isUnverifiable();
bool isSyscall();
bool isMacroop();
bool isMicroop();
bool isDelayedCommit();
bool isLastMicroop();
bool isFirstMicroop();
bool isMicroBranch();

// Determintes which functional unit to send instruction to
OpClass opClass();

// Get register IDs
const RegId &destRegIdx(int i);
const RegId &srcRegIdx(int i);

// Utils
const ExtMachInst machInst;

protected:
RegId \_destRegIdx&#91;MaxInstDestRegs];
RegId \_srcRegIdx&#91;MaxInstSrcRegs];

const char *mnemonic;
virtual std::string generateDisassembly(Addr pc, const Loader::SymbolTable *symtab);
};</code></pre>

  </div>
  
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap ub-hide"
        id="ub-tabbed-content--panel-1" aria-labelledby="ub-tabbed-content--tab-1">
    <pre class="wp-block-code"><code>// build/RISCV/arch/riscv/insts/static_inst.hh
class RiscvStaticInst : public StaticInst {
 protected:
  using StaticInst::StaticInst;

public:
void advancePC(PCState &pc) const override { pc.advance(); }

size_t asBytes(void \*buf, size_t size) override {
return simpleAsBytes(buf, size, machInst);
}
};</code></pre>

  </div>
  
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap ub-hide"
        id="ub-tabbed-content--panel-2" aria-labelledby="ub-tabbed-content--tab-2">
    <pre class="wp-block-code"><code>// build/RISCV/arch/riscv/insts/static_inst.hh
class RiscvMacroInst : public RiscvStaticInst {
 protected:
  std::vector&lt;StaticInstPtr> microops;

RiscvMacroInst(const char \*mnem, ExtMachInst \_machInst, OpClass **opClass) : RiscvStaticInst(mnem, \_machInst, **opClass) {
flags&#91;IsMacroop] = true;
}

~RiscvMacroInst() { microops.clear(); }

StaticInstPtr fetchMicroop(MicroPC upc) const override {
return microops&#91;upc];
}

Fault initiateAcc(ExecContext *xc, Trace::InstRecord *traceData) const override {
panic("Tried to execute a macroop directly!\n");
}

Fault completeAcc(PacketPtr pkt, ExecContext *xc,
Trace::InstRecord *traceData) const override {
panic("Tried to execute a macroop directly!\n");
}

Fault execute(ExecContext *xc, Trace::InstRecord *traceData) const override {
panic("Tried to execute a macroop directly!\n");
}
};</code></pre>

  </div>
  
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap active"
        id="ub-tabbed-content--panel-3" aria-labelledby="ub-tabbed-content--tab-3">
    <pre class="wp-block-code"><code>// build/RISCV/arch/riscv/insts/static_inst.hh
class RiscvMicroInst : public RiscvStaticInst {
 protected:
  RiscvMicroInst(const char *mnem, ExtMachInst _machInst, OpClass __opClass) : RiscvStaticInst(mnem, _machInst, __opClass) {
    flags&#91;IsMicroop] = true;
  }

void advancePC(PCState &pcState) const override;
};</code></pre>

  </div>
</div></div>

<div class="wp-block-jetpack-markdown">
  <p>
    Keep in mind that a `StaticInst` is static, meaning that it is a one-one mapping from a machine instruction. More advanced CPUs can choose to create a `DynInst` object from the decoded `StaticInst`. This `DynInst` can include dynamic information such as predicted branch sequence number / pipeline status etc.
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <p>
    Examples of `DynInst` dynamic information includes:
  </p>
</div>

- The PC of the instruction
- The renamed register indices of the source and destination registers
- The predicted next-PC
- The instruction result
- The thread number of the instruction
- The CPU the instruction is executing on
- Whether or not the instruction is squashed

### 2.1.4 Decoder

<div class="wp-block-jetpack-markdown">
  <p>
    The `Decoder` generated by the `*.isa` files expose two important functions: `moreBytes` and `decode`. The former is used to copy the fetched machine instruction into the `Decoder` instance (I believe there are no hardware logic behind this). `decode` is invoked to return a `StaticInstPtr` (literally a pointer to a `StaticInst`).
  </p>
</div>

<pre class="wp-block-code"><code>// build/RISCV/arch/riscv/decoder.hh
class Decoder : public InstDecoder {
 private:
  DecodeCache::InstMap&lt;ExtMachInst> instMap;
  bool aligned;
  bool mid;
  bool more;

 protected:
  ExtMachInst emi;
  bool instDone;

 public:
  Decoder(ISA *isa = nullptr) { reset(); }

  void process() {}
  void reset();

  inline bool compressed(ExtMachInst inst) { return (inst & 0x3) &lt; 0x3; }

  void moreBytes(const PCState &pc, Addr fetchPC, MachInst inst);

  bool needMoreBytes() { return more; }
  bool instReady() { return instDone; }
  void takeOverFrom(Decoder *old) {}

  StaticInstPtr decodeInst(ExtMachInst mach_inst);

  StaticInstPtr decode(ExtMachInst mach_inst, Addr addr);
  StaticInstPtr decode(RiscvISA::PCState &nextPC);
};</code></pre>

## 2.2 CPU

### 2.2.1 ExecContext

<div class="wp-block-jetpack-markdown">
  <p>
    So far, we have understood that the ISA DSL generates a decoder that maps machine instructions to `StaticInst` objects. However, the `StaticInst` object needs a way to access the registers, which belongs to the CPU (remember that ISA and CPU are supposed to be independent). This is achieved through the `ExecContext` object. Everytime `execute`, `initiateAcc` or `complateAcc` is called, an `ExecContext` pointer is passed as a parameter.
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <p>
    The `ExecContext` interface provides methods to:
  </p>
</div>

- Read and write PC information
- Read and write integer, floating point, and control registers
- Read and write memory
- Record and return the address of a memory access, pre-fetching, and trigger a system call
- Trigger some full-system mode functionality (interrupts?)

<pre class="wp-block-code"><code>// build/RISCV/cpu/exec_context.hh
class ExecContext {
 public:
  using VecRegContainer = TheISA::VecRegContainer;
  using VecElem = TheISA::VecElem;
  using VecPredRegContainer = TheISA::VecPredRegContainer;

 public:
  // Integer Registers
  virtual RegVal readIntRegOperand(const StaticInst *si, int idx);

  virtual void setIntRegOperand(const StaticInst *si, int idx, RegVal val);

  // Floating Point Registers
  virtual RegVal readFloatRegOperandBits(const StaticInst *si, int idx);

  virtual void setFloatRegOperandBits(const StaticInst *si, int idx, RegVal val);

  // Vector Registers
  virtual const VecRegContainer &readVecRegOperand(const StaticInst *si, int idx);

  virtual VecRegContainer &getWritableVecRegOperand(const StaticInst *si, int idx);

  virtual void setVecRegOperand(const StaticInst *si, int idx, const VecRegContainer &val);

  virtual ConstVecLane8 readVec8BitLaneOperand(const StaticInst *si, int idx);
  virtual ConstVecLane16 readVec16BitLaneOperand(const StaticInst *si, int idx);
  virtual ConstVecLane32 readVec32BitLaneOperand(const StaticInst *si, int idx);
  virtual ConstVecLane64 readVec64BitLaneOperand(const StaticInst *si, int idx);

  virtual void setVecLaneOperand(const StaticInst *si, int idx, const LaneData&lt;LaneSize::Byte> &val);
  virtual void setVecLaneOperand(const StaticInst *si, int idx, const LaneData&lt;LaneSize::TwoByte> &val);
  virtual void setVecLaneOperand(const StaticInst *si, int idx, const LaneData&lt;LaneSize::FourByte> &val);
  virtual void setVecLaneOperand(const StaticInst *si, int idx, const LaneData&lt;LaneSize::EightByte> &val);

  virtual VecElem readVecElemOperand(const StaticInst *si, int idx);
  virtual void setVecElemOperand(const StaticInst *si, int idx, const VecElem val);

  virtual const VecPredRegContainer &readVecPredRegOperand(const StaticInst *si, int idx);

  virtual VecPredRegContainer &getWritableVecPredRegOperand(const StaticInst *si, int idx);

  virtual void setVecPredRegOperand(const StaticInst *si, int idx, const VecPredRegContainer &val);

  // Control Registers
  virtual RegVal readCCRegOperand(const StaticInst *si, int idx);
  virtual void setCCRegOperand(const StaticInst *si, int idx, RegVal val);

  // Misc Registers
  virtual RegVal readMiscRegOperand(const StaticInst *si, int idx);
  virtual void setMiscRegOperand(const StaticInst *si, int idx, RegVal val);
  virtual RegVal readMiscReg(int misc_reg);
  virtual void setMiscReg(int misc_reg, RegVal val);

  // PC State
  virtual PCState pcState();

  virtual void pcState(const PCState &val);

  // Memory
  virtual Fault readMem(Addr addr, uint8_t *data, unsigned int size, Request::Flags flags, const std::vector&lt;bool> &byte_enable = std::vector&lt;bool>());

  virtual Fault initiateMemRead(Addr addr, unsigned int size, Request::Flags flags, const std::vector&lt;bool> &byte_enable = std::vector&lt;bool>());

  // For atomic-mode contexts, perform an atomic memory write operation.
  // For timing-mode contexts, initiate a timing memory write operation.
  virtual Fault writeMem(uint8_t *data, unsigned int size, Addr addr, Request::Flags flags, uint64_t *res, const std::vector&lt;bool> &byte_enable = std::vector&lt;bool>());

  // For atomic-mode contexts, perform an atomic AMO (a.k.a., Atomic Read-Modify-Write Memory Operation)
  virtual Fault amoMem(Addr addr, uint8_t *data, unsigned int size, Request::Flags flags, AtomicOpFunctorPtr amo_op);

  // For timing-mode contexts, initiate an atomic AMO (atomic read-modify-write memory operation)
  virtual Fault initiateMemAMO(Addr addr, unsigned int size, Request::Flags flags, AtomicOpFunctorPtr amo_op);

  // Others
  virtual void setStCondFailures(unsigned int sc_failures);

  virtual unsigned int readStCondFailures();

  virtual void syscall(Fault *fault);

  virtual ThreadContext *tcBase();

  // ARM-Specific Interfaces
  virtual bool readPredicate();

  virtual void setPredicate(bool val);

  virtual bool readMemAccPredicate();

  virtual void setMemAccPredicate(bool val);

  // X86-Specific Interfaces
  virtual void demapPage(Addr vaddr, uint64_t asn);
  virtual void armMonitor(Addr address);
  virtual bool mwait(PacketPtr pkt);
  virtual void mwaitAtomic(ThreadContext *tc);
  virtual AddressMonitor *getAddrMonitor();
};</code></pre>

# 3 ISA Parser Structure

The single most important thing to keep in mind while reading through this section is that the ISA DSL serves as a sort of **templating** language. Its main purpose is to **generate** C++ code based on reusable **templates**.

<div class="wp-block-jetpack-markdown">
  <p>
    Another thing to note that the ISA DSL is mainly **parsed using regex expressions** (see `isa-parser.py`). Hence, there are some **constraints** on the way that variables have to be defined. E.g. `A += 1` is not allowed as a regex expression would not be able to tell that A is both a source and sink (because it only appears on the LHS of the `=` symbol).
  </p>
</div>

## 3.1 How different ISA files are linked?

<div class="wp-block-jetpack-markdown">
  <p>
    In gem5, all ISAs are implemented in multiple `*.isa` files. They are usually then imported in order in `main.isa` using statements like `##include operands.isa`. In `SConscript`, the compiler will be notified via the `ISADesc('isa/main.isa')` statement.
  </p>
</div>

## 3.2 Bitfield

A **bitfield** is simply a **continuous range of bits** within a machine instruction. By defining a bitfield definition, the relevant bitfield value (sign-extended or unsigned) will be automatically extracted when the machine instruction is passed to the decoder. This is done via generated C++ macros. We can have multiple bitfields for different instruction formats using overlapping bits, the point is that now you can use a bitfield name instead of bit index in the decode block.

<pre class="wp-block-code"><code>// build/RISCV/arch/riscv/isa/bitfield.isa
def bitfield QUADRANT &lt;1:0>;
def bitfield OPCODE &lt;6:2>;
def bitfield ALL &lt;31:0>;</code></pre>

<div class="wp-block-jetpack-markdown">
  <p>
    The above bitfield definitions will generate the following code:
  </p>
</div>

<pre class="wp-block-code"><code>// build/RISCV/arch/riscv/generated/decoder-ns.hh.inc
#undef QUADRANT
#define QUADRANT bits(machInst,  1,  0)
#undef OPCODE
#define OPCODE bits(machInst,  6,  2)
#undef ALL
#define ALL bits(machInst, 31,  0)</code></pre>

<div class="wp-block-jetpack-markdown">
  <p>
    These bitfields values are safe to use even in the constructors of `StaticInst` objects.
  </p>
</div>

### 3.2.2 Decode

<div class="wp-block-jetpack-markdown">
  <p>
    Once we have named bitfields, we can decode a machine instruction by analyzing bitfields in a sequential manner (the issue is to design an efficient sequence such that it makes the most sense in hardware). A decode block is similar to a C++ case statement, where the `decode` keyword is followed by a bitfield name.
  </p>
</div>

<div class="wp-block-ub-tabbed-content wp-block-ub-tabbed-content-holder wp-block-ub-tabbed-content-horizontal-holder-mobile wp-block-ub-tabbed-content-horizontal-holder-tablet" id="ub-tabbed-content-9a7b58ef-12f0-4ece-857b-19482d9e02e4">
  <div role="tablist" class="wp-block-ub-tabbed-content-tab-holder  horizontal-tab-width-mobile horizontal-tab-width-tablet">
    <div class="wp-block-ub-tabbed-content-tabs-title wp-block-ub-tabbed-content-tabs-title-mobile-horizontal-tab wp-block-ub-tabbed-content-tabs-title-tablet-horizontal-tab">
      <div role="tab" id="ub-tabbed-content-9a7b58ef-12f0-4ece-857b-19482d9e02e4-tab-0" aria-controls="ub-tabbed-content-9a7b58ef-12f0-4ece-857b-19482d9e02e4-panel-0" aria-selected="false" class = "wp-block-ub-tabbed-content-tab-title-wrap"> 
      
      <div class="wp-block-ub-tabbed-content-tab-title">
        Actual
      </div>
    </div><div role="tab" id="ub-tabbed-content-9a7b58ef-12f0-4ece-857b-19482d9e02e4-tab-1" aria-controls="ub-tabbed-content-9a7b58ef-12f0-4ece-857b-19482d9e02e4-panel-1" aria-selected="true" class = "wp-block-ub-tabbed-content-tab-title-wrap active"> 
    
    <div class="wp-block-ub-tabbed-content-tab-title">
      Abstract
    </div>
  </div>
</div></div>

<div class="wp-block-ub-tabbed-content-tabs-content ">
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap ub-hide"
        id="ub-tabbed-content--panel-0" aria-labelledby="ub-tabbed-content--tab-0">
    <pre class="wp-block-code"><code>decode OPCODE default Unknown::unknown() {
  format Integer {
    0x0: add({{ Rc = Ra + Rb }}, "Add");
    0x1: sub({{ Rc = Ra - Rb }}, "Sub");
  }
}</code></pre>
  </div>
  
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap active"
        id="ub-tabbed-content--panel-1" aria-labelledby="ub-tabbed-content--tab-1">
    <pre class="wp-block-code"><code>decode &lt;bitfield> default &lt;default-format>::&lt;default-mnemonic>() {
  format &lt;format> {
    &lt;case>: &lt;mnemonic>({{ &lt;code-literal> }}, &lt;args>);
    &lt;case>: &lt;mnemonic>({{ &lt;code-literal> }}, &lt;args>);
  }
}</code></pre>
  </div>
</div></div>

<div class="wp-block-jetpack-markdown">
  <p>
    Recall that the function of the `TheISA::Decoder` object (which is generated from ISA files), is to map a machine instruction into a `StaticInst` object. This is done through the following steps:
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <ol>
    <li>
      `decode` section in `.isa` file defines the `decodeInst(machInst)` method in the `Decoder` <ul>
        <li>
          `machInst` is parsed based on its different `bitfield` values
        </li>
      </ul>
    </li>
    
    <li>
      `decodeInst` calls the appropriate constructor to return a `StaticInst` object <ul>
        <li>
          `format` section specifies the type of instruction (different type of instruction use different `templates` to generate its C++ class)
        </li>
        <li>
          `mnemonic` is used to generate the C++ class name (there are different instructions under one `format`, e.g. integer add / sub / mul)
        </li>
      </ul>
    </li>
  </ol>
</div>

<div class="wp-block-jetpack-markdown">
  <p>
    Take note that when the ISA description file is processed, each instruction definition invokes a function in `isa_parser.py` to generate the C++ code. Hence, it is not advisable to repeat instruction definitions in `.isa` files (ideally your decoder should only have one path to the constructor for each type of machine instruction, and catch all unknown instructions with a default format). Else, C++ will face a multiple definition issue.
  </p>
</div>

#### Code Literal

<div class="wp-block-jetpack-markdown">
  <p>
    The syntax `{{ ... }}` is often used in the ISA DSL, they are called `code literals`. They specify the action to be performed to the registers. The ISA Parser uses regex to recognize the symbols for the source and destination registers. These register symbols, called `operands`, must be defined in an `operand` section. They will then be processed by the ISA Parser to perform the desired action using the functions exposed by `ExecContext`.
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <p>
    For example, `Integer::add({{ Rc = Ra + Rb }})` might be parsed in the following manner. When the `machInst` is `addi r1 r2 r3`, the `StaticInst` will have `srcRegId[0]  = 2`, `srcRegId[1] = 3`, `desRegId[0] = 1`. Then, the `execute` method will perform:
  </p>
</div>

<pre class="wp-block-code"><code>XXX::execute(ExecContext *xc, ...) {
  // other generated code
  &lt;type> ra = xc->readIntRegOperand(this, srcRegId&#91;0]);
  &lt;type> rb = xc->readIntRegOperand(this, srcRegId&#91;1]);
  &lt;type> rc = xc->setIntRegOperand(this, desRegId&#91;0], ra + rb);
}</code></pre>

<div class="wp-block-jetpack-markdown">
  <p>
    It might already be evident from this example that both `operand` and `operand type` (signed, unsigned, int, float etc.) have to be defined to generate a complete `execute` method. Each `operand` has to be associated with an `operand type` for the parser to define its action.
  </p>
</div>

### 3.2.3 Instruction Format

<pre class="wp-block-code"><code>def format Integer(code_literal, msg="default") {{
    iop = InstObjParams(name, Name, IntInst,
 {}, &#91;])
    header_output = ImmDeclare.subst(iop)
    decoder_output = ImmConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = ImmExecute.subst(iop)
}};</code></pre>

<div class="wp-block-jetpack-markdown">
  <p>
    The `def format` keywords in ISA DSL specifies an instruction format definition (which is used in every decode block case). The definition of the format decides on the number and type of arguments to be provided in the `decode` block (in this case the `Integer::add` function has to be called with a code literal and an optional message). The syntax inside the `{{ ... }}` code literal is basically a Python script that assigns value to four special variables: `header_output`, `decoder_output`, `decoder_block` and `exec_output`.
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <p>
    These four variable contains a long string (of C++ code) that will be outputted to the files `decoder-ns.hh.inc` (class declaration), `decoder-ns.cc.inc` (class constructor), `decoder-method.cc.inc` (invoke constructor) and `exec-ns.cc.inc` (class method definitions) respectively. In summary:
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <ul>
    <li>
      `header_output`: declares class in `decoder-ns.hh.inc`
    </li>
    <li>
      `decoder_output`: defines class constructor in `decoder-ns.cc.inc`
    </li>
    <li>
      `decoder_block`: invokes constructor in `Decoder::decodeInst(machInst)` (`decoder-method.cc.inc`), e.g. `return new C_addi4spn`
    </li>
    <li>
      `exec_output`: class methods in `exec-ns.cc.inc`, e.g. `execute`, `initiateMemAcc`, etc.
    </li>
  </ul>
</div>

<div class="wp-block-jetpack-markdown">
  <p>
    These code strings are generated using `template` blocks which acts as a boilerplate for each component (e.g. constructor, class declaration, execute method etc.). This is usually done by passing a `InstObjParams` object into the `subst` function of a `template` definition. We will look at these concepts in the following section.
  </p>
</div>

**Things to take note**

<div class="wp-block-jetpack-markdown">
  <ol>
    <li>
      format definition supports the syntax `def format fmtName(arg1, *args)`
    </li>
    <li>
      aside from the explicit arguments, the arguments `name` (=instructor mnemonic) and `Name` (capitalized `name`) will be available for use inside the format definition body
    </li>
    <li>
      inside the format definition body, the string literal `%(CPU_exec_context)s` will be automatically substituted with the CPU's execution context's class name. This allows for some tweaking of code based on CPU (not really used as it sort of violates the module independence). If used, strings will be replicated once for each CPU model (defined in `built_opt/` env variables).
    </li>
  </ol>
</div>

### 3.2.4 Template Definition

<div class="wp-block-jetpack-markdown">
  <p>
    As mentioned above, template definitions are used to generate code strings. Each template definition creates a Python object with the same name which has a `subst(InstObjParams iop)` method. The `InstObjParams` exposes its class members to the template definition body for string substitution.
  </p>
</div>

**InstObjParams**

<pre class="wp-block-code"><code>class InstObjParams(object):
    def __init__ (self, parser, mem, class_name, base_class = "", snippets = {}, opt_args = &#91;]):
        # snippets can be a string, if so, it is treated as the snippet&#91;"code"] field
        # code ...</code></pre>

<div class="wp-block-jetpack-markdown">
  <p>
    Note that when we instantiate `InstObjParams` in the template body, it is a wrapped function, so we do not have to provide the `parser` argument (it is literally the ISA Parser instance). The constructor arguments are as follows:
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <ul>
    <li>
      `mem`: mnemonic
    </li>
    <li>
      `class_name`: C++ class name (exposed to template body for use, e.g. `return new %(class_name)s(machInst)`
    </li>
    <li>
      `base_class`: Base class name
    </li>
    <li>
      `snippets`: dictionary of fields (usually code snippets) exposed to template body (e.g. `code`, `imm_code` to process immediate operands etc.)
    </li>
    <li>
      `opt_args`: flags or OpClass (parsed based on string value)
    </li>
  </ul>
</div>

<div class="wp-block-jetpack-markdown">
  <p>
    Given the `InstObjParams`, all the class members are available for string substitution. In addition, the following substitution strings are available (not comprehensive I think): `op_decl` (declare operand variables), `op_src_decl`, `op_dest_decl`, `op_rd` (read operand register value), `op_wb` (writeback register values), `constructor`, `mnemonic`, `flags`, `op_class`.
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <p>
    Till now, we have basically understood most of the ISA Parser operations. There are some more minor tricks we can perform such as `Bitfield Operator` etc. which will be explained later. We will take a look at an example of the ISA template and generated C++ code for a typical **RISCV register operation**:
  </p>
</div>

<div class="wp-block-ub-tabbed-content wp-block-ub-tabbed-content-holder wp-block-ub-tabbed-content-horizontal-holder-mobile wp-block-ub-tabbed-content-horizontal-holder-tablet" id="ub-tabbed-content-db3ab6ef-8fca-4617-82f8-bcd49adab768">
  <div role="tablist" class="wp-block-ub-tabbed-content-tab-holder  horizontal-tab-width-mobile horizontal-tab-width-tablet">
    <div class="wp-block-ub-tabbed-content-tabs-title wp-block-ub-tabbed-content-tabs-title-mobile-horizontal-tab wp-block-ub-tabbed-content-tabs-title-tablet-horizontal-tab">
      <div role="tab" id="ub-tabbed-content-db3ab6ef-8fca-4617-82f8-bcd49adab768-tab-0" aria-controls="ub-tabbed-content-db3ab6ef-8fca-4617-82f8-bcd49adab768-panel-0" aria-selected="false" class = "wp-block-ub-tabbed-content-tab-title-wrap"> 
      
      <div class="wp-block-ub-tabbed-content-tab-title">
        Instruction Format
      </div>
    </div><div role="tab" id="ub-tabbed-content-db3ab6ef-8fca-4617-82f8-bcd49adab768-tab-1" aria-controls="ub-tabbed-content-db3ab6ef-8fca-4617-82f8-bcd49adab768-panel-1" aria-selected="false" class = "wp-block-ub-tabbed-content-tab-title-wrap"> 
    
    <div class="wp-block-ub-tabbed-content-tab-title">
      header_output
    </div>
  </div><div role="tab" id="ub-tabbed-content-db3ab6ef-8fca-4617-82f8-bcd49adab768-tab-2" aria-controls="ub-tabbed-content-db3ab6ef-8fca-4617-82f8-bcd49adab768-panel-2" aria-selected="false" class = "wp-block-ub-tabbed-content-tab-title-wrap"> 
  
  <div class="wp-block-ub-tabbed-content-tab-title">
    decoder_output
  </div>
</div><div role="tab" id="ub-tabbed-content-db3ab6ef-8fca-4617-82f8-bcd49adab768-tab-3" aria-controls="ub-tabbed-content-db3ab6ef-8fca-4617-82f8-bcd49adab768-panel-3" aria-selected="true" class = "wp-block-ub-tabbed-content-tab-title-wrap active">

<div class="wp-block-ub-tabbed-content-tab-title">
  decode_block
</div></div><div role="tab" id="ub-tabbed-content-db3ab6ef-8fca-4617-82f8-bcd49adab768-tab-4" aria-controls="ub-tabbed-content-db3ab6ef-8fca-4617-82f8-bcd49adab768-panel-4" aria-selected="false" class = "wp-block-ub-tabbed-content-tab-title-wrap">

<div class="wp-block-ub-tabbed-content-tab-title">
  exec_output
</div></div></div></div>

<div class="wp-block-ub-tabbed-content-tabs-content ">
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap ub-hide"
        id="ub-tabbed-content--panel-0" aria-labelledby="ub-tabbed-content--tab-0">
    <pre class="wp-block-code"><code>def format ROp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'RegOp', code, opt_flags)
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = BasicExecute.subst(iop)
}};</code></pre>
  </div>
  
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap ub-hide"
        id="ub-tabbed-content--panel-1" aria-labelledby="ub-tabbed-content--tab-1">
    <p>
      **ISA Template**
    </p>
    
    <pre class="wp-block-code"><code>def template BasicDeclare {{
    class %(class_name)s : public %(base_class)s {
    public:
        %(class_name)s(MachInst machInst);
        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        using %(base_class)s::generateDisassembly;
    };
}};</code></pre>
    
    <p>
      **Generated**
    </p>
    
    <pre class="wp-block-code"><code>class Add : public RegOp {
 public:
  /// Constructor.
  Add(MachInst machInst);
  Fault execute(ExecContext *, Trace::InstRecord *) const override;
  using RegOp::generateDisassembly;
};</code></pre>
  </div>
  
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap ub-hide"
        id="ub-tabbed-content--panel-2" aria-labelledby="ub-tabbed-content--tab-2">
    <p>
      **ISA Template**
    </p>
    
    <pre class="wp-block-code"><code>def template BasicConstructor {{
    %(class_name)s::%(class_name)s(MachInst machInst) 
        : %(base_class)s("%(mnemonic)s", machInst, %(op_class)s)
    {
        %(constructor)s;
    }
}};</code></pre>
    
    <p>
      **Generated**
    </p>
    
    <pre class="wp-block-code"><code>Add::Add(MachInst machInst)
    : RegOp("add", machInst, IntAluOp) {
  _numSrcRegs = 0;
  _numDestRegs = 0;
  _numFPDestRegs = 0;
  _numVecDestRegs = 0;
  _numVecElemDestRegs = 0;
  _numVecPredDestRegs = 0;
  _numIntDestRegs = 0;
  _numCCDestRegs = 0;
  _destRegIdx&#91;_numDestRegs++] = RegId(IntRegClass, RD);
  _numIntDestRegs++;
  _srcRegIdx&#91;_numSrcRegs++] = RegId(IntRegClass, RS1);
  _srcRegIdx&#91;_numSrcRegs++] = RegId(IntRegClass, RS2);
  flags&#91;IsInteger] = true;
  ;
}</code></pre>
  </div>
  
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap active"
        id="ub-tabbed-content--panel-3" aria-labelledby="ub-tabbed-content--tab-3">
    <p>
      **ISA Template**
    </p>
    
    <pre class="wp-block-code"><code>def template BasicDecode {{
    return new %(class_name)s(machInst);
}};</code></pre>
    
    <p>
      **Generated**
    </p>
    
    <pre class="wp-block-code"><code>StaticInstPtr RiscvISA::Decoder::decodeInst(RiscvISA::ExtMachInst machInst) {
  switch (QUADRANT) {
    case 0xc:
      switch (FUNCT3) {
        case 0x0:
          switch (FUNCT7) {
            case 0x0:
              return new Add(machInst);
          }
      }
  }
}</code></pre>
  </div>
  
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap ub-hide"
        id="ub-tabbed-content--panel-4" aria-labelledby="ub-tabbed-content--tab-4">
    <p>
      **ISA Template**
    </p>
    
    <pre class="wp-block-code"><code>def template BasicExecute
{{
    Fault %(class_name)s::execute(ExecContext *xc, 
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        %(op_decl)s;
        %(op_rd)s;
        if (fault == NoFault) {
            %(code)s;
            if (fault == NoFault) {
                %(op_wb)s;
            }
        }
        return fault;
    }

}};</code></pre>

    <p>
      **Generated**
    </p>

    <pre class="wp-block-code"><code>Fault Add::execute(ExecContext *xc,
                   Trace::InstRecord *traceData) const {

Fault fault = NoFault;

uint64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
Rs1 = xc->readIntRegOperand(this, 0);
Rs2 = xc->readIntRegOperand(this, 1);
;
if (fault == NoFault) {
Rd = Rs1 + Rs2;
;
if (fault == NoFault) {
{
uint64_t final_val = Rd;
xc->setIntRegOperand(this, 0, final_val);

        if (traceData) {
          traceData->setData(final_val);
        }
      };
    }

}
return fault;
}</code></pre>

  </div>
</div></div>

### 3.2.5 Output and Let Blocks

<div class="wp-block-jetpack-markdown">
  <p>
    An output block is used to include raw C++ code verbatim in the output files, usually used to include headers. They have the format:
  </p>
</div>

<pre class="wp-block-code"><code>output &lt;destination> {{
    // code ...
}}</code></pre>

<div class="wp-block-jetpack-markdown">
  <p>
    The `destination` field must be `header`, `decoder` or `exec`, which will be copied to `header_output`, `decoder_output` and `exec_output` respectively. The code order is preserved when the blocks are parsed by the ISA Parser. An example is:
  </p>
</div>

<pre class="wp-block-code"><code>output header {{
    #include &lt;iomanip>
    #include &lt;sstream>
    #include &lt;string>
    #include &lt;tuple>
    #include &lt;vector>

    #include "arch/riscv/insts/amo.hh"
    #include "arch/riscv/insts/compressed.hh"
    #include "arch/riscv/insts/mem.hh"
    #include "arch/riscv/insts/pseudo.hh"
    #include "arch/riscv/insts/standard.hh"
    #include "arch/riscv/insts/static_inst.hh"
    #include "arch/riscv/insts/unknown.hh"
    #include "cpu/static_inst.hh"
    #include "mem/packet.hh"
    #include "mem/request.hh"
}};</code></pre>

<div class="wp-block-jetpack-markdown">
  <p>
    Let blocks are used to provide **global** Python code. An example of its use is when memory operations are defined.
  </p>
</div>

<div class="wp-block-ub-tabbed-content wp-block-ub-tabbed-content-holder wp-block-ub-tabbed-content-horizontal-holder-mobile wp-block-ub-tabbed-content-horizontal-holder-tablet" id="ub-tabbed-content-16e2b298-ce9b-4b0f-9210-8875a622e09f">
  <div role="tablist" class="wp-block-ub-tabbed-content-tab-holder  horizontal-tab-width-mobile horizontal-tab-width-tablet">
    <div class="wp-block-ub-tabbed-content-tabs-title wp-block-ub-tabbed-content-tabs-title-mobile-horizontal-tab wp-block-ub-tabbed-content-tabs-title-tablet-horizontal-tab">
      <div role="tab" id="ub-tabbed-content-16e2b298-ce9b-4b0f-9210-8875a622e09f-tab-0" aria-controls="ub-tabbed-content-16e2b298-ce9b-4b0f-9210-8875a622e09f-panel-0" aria-selected="false" class = "wp-block-ub-tabbed-content-tab-title-wrap"> 
      
      <div class="wp-block-ub-tabbed-content-tab-title">
        Instruction Format
      </div>
    </div><div role="tab" id="ub-tabbed-content-16e2b298-ce9b-4b0f-9210-8875a622e09f-tab-1" aria-controls="ub-tabbed-content-16e2b298-ce9b-4b0f-9210-8875a622e09f-panel-1" aria-selected="false" class = "wp-block-ub-tabbed-content-tab-title-wrap"> 
    
    <div class="wp-block-ub-tabbed-content-tab-title">
      header_output
    </div>
  </div><div role="tab" id="ub-tabbed-content-16e2b298-ce9b-4b0f-9210-8875a622e09f-tab-2" aria-controls="ub-tabbed-content-16e2b298-ce9b-4b0f-9210-8875a622e09f-panel-2" aria-selected="false" class = "wp-block-ub-tabbed-content-tab-title-wrap"> 
  
  <div class="wp-block-ub-tabbed-content-tab-title">
    decoder_output
  </div>
</div><div role="tab" id="ub-tabbed-content-16e2b298-ce9b-4b0f-9210-8875a622e09f-tab-3" aria-controls="ub-tabbed-content-16e2b298-ce9b-4b0f-9210-8875a622e09f-panel-3" aria-selected="true" class = "wp-block-ub-tabbed-content-tab-title-wrap active">

<div class="wp-block-ub-tabbed-content-tab-title">
  decode_block
</div></div><div role="tab" id="ub-tabbed-content-16e2b298-ce9b-4b0f-9210-8875a622e09f-tab-4" aria-controls="ub-tabbed-content-16e2b298-ce9b-4b0f-9210-8875a622e09f-panel-4" aria-selected="false" class = "wp-block-ub-tabbed-content-tab-title-wrap">

<div class="wp-block-ub-tabbed-content-tab-title">
  exec_output
</div></div></div></div>

<div class="wp-block-ub-tabbed-content-tabs-content ">
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap ub-hide"
        id="ub-tabbed-content--panel-0" aria-labelledby="ub-tabbed-content--tab-0">
    <pre class="wp-block-code"><code>def format ROp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'RegOp', code, opt_flags)
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
def format Load(memacc_code, ea_code = {{EA = Rs1 + offset;}},
                offset_code={{offset = sext&lt;12>(IMM12);}},
                mem_flags=&#91;], inst_flags=&#91;]) {{

    (header_output, decoder_output, decode_block, exec_output) =  LoadStoreBase(name, Name, offset_code, \
                  ea_code, memacc_code, mem_flags, inst_flags, \
                  'Load', exec_template_base='Load')

}};

let {{
def LoadStoreBase(name, Name, ea_code, memacc_code,
mem_flags, inst_flags, base_class='MemOp',
decode_template=BasicDecode, exec_template_base=''):

    # Make sure flags are in lists (convert to lists if not).
    mem_flags = makeList(mem_flags)
    inst_flags = makeList(inst_flags)

    # Generate InstObjParams for the memory access.
    iop = InstObjParams(name, Name, base_class,
                        {'ea_code': ea_code,
                         'memacc_code': memacc_code},
                        inst_flags)

    if mem_flags:
        s = '\n\tmemAccessFlags = ' + '|'.join(mem_flags) + ';'
        iop.constructor += s

    fullExecTemplate = eval(exec_template_base + 'Execute')
    initiateAccTemplate = eval(exec_template_base + 'InitiateAcc')
    completeAccTemplate = eval(exec_template_base + 'CompleteAcc')

    # (header_output, decoder_output, decode_block, exec_output)
    return (LoadStoreDeclare.subst(iop),
            LoadStoreConstructor.subst(iop),
            decode_template.subst(iop),
            fullExecTemplate.subst(iop)
            + initiateAccTemplate.subst(iop)
            + completeAccTemplate.subst(iop))

}};</code></pre>

  </div>
  
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap ub-hide"
        id="ub-tabbed-content--panel-1" aria-labelledby="ub-tabbed-content--tab-1">
    <p>
      **ISA Template**
    </p>
    
    <pre class="wp-block-code"><code>def template LoadStoreDeclare {{
    class %(class_name)s : public %(base_class)s
    {
    public:
        %(class_name)s(ExtMachInst machInst);

        Fault execute(ExecContext *, Trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, Trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *, Trace::InstRecord *) const override;
    };

}};</code></pre>

    <p>
      **Generated**
    </p>

    <pre class="wp-block-code"><code>class Lb : public Load {

public:
Lb(ExtMachInst machInst);

Fault execute(ExecContext _, Trace::InstRecord _) const override;
Fault initiateAcc(ExecContext _, Trace::InstRecord _) const override;
Fault completeAcc(PacketPtr, ExecContext _, Trace::InstRecord _) const override;
};</code></pre>

  </div>
  
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap ub-hide"
        id="ub-tabbed-content--panel-2" aria-labelledby="ub-tabbed-content--tab-2">
    <p>
      **ISA Template**
    </p>
    
    <pre class="wp-block-code"><code>def template LoadStoreConstructor {{
    %(class_name)s::%(class_name)s(ExtMachInst machInst):
        %(base_class)s("%(mnemonic)s", machInst, %(op_class)s)
    {
        %(constructor)s;
        %(offset_code)s;
    }
}};</code></pre>
    
    <p>
      **Generated**
    </p>
    
    <pre class="wp-block-code"><code>Lb::Lb(ExtMachInst machInst) : Load("lb", machInst, MemReadOp) {
  _numSrcRegs = 0;
  _numDestRegs = 0;
  _numFPDestRegs = 0;
  _numVecDestRegs = 0;
  _numVecElemDestRegs = 0;
  _numVecPredDestRegs = 0;
  _numIntDestRegs = 0;
  _numCCDestRegs = 0;
  _destRegIdx&#91;_numDestRegs++] = RegId(IntRegClass, RD);
  _numIntDestRegs++;
  _srcRegIdx&#91;_numSrcRegs++] = RegId(IntRegClass, RS1);
  flags&#91;IsInteger] = true;
  flags&#91;IsLoad] = true;
  flags&#91;IsMemRef] = true;
  ;
  offset = sext&lt;12>(IMM12);
  ;
}</code></pre>
  </div>
  
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap active"
        id="ub-tabbed-content--panel-3" aria-labelledby="ub-tabbed-content--tab-3">
    <p>
      **ISA Template**
    </p>
    
    <pre class="wp-block-code"><code>def template BasicDecode {{
    return new %(class_name)s(machInst);
}};</code></pre>
    
    <p>
      **Generated**
    </p>
    
    <pre class="wp-block-code"><code>StaticInstPtr RiscvISA::Decoder::decodeInst(RiscvISA::ExtMachInst machInst) {
  switch (QUADRANT) {
    case 0x3:
      switch (OPCODE) {
        case 0x0:
          switch (FUNCT3) {
            case 0x0:
              return new Lb(machInst);
          }
      }
  }
}</code></pre>
  </div>
  
  <div role="tabpanel" class="wp-block-ub-tabbed-content-tab-content-wrap ub-hide"
        id="ub-tabbed-content--panel-4" aria-labelledby="ub-tabbed-content--tab-4">
    <p>
      **ISA Template**
    </p>
    
    <pre class="wp-block-code"><code>def template LoadExecute {{
    Fault %(class_name)s::execute(ExecContext *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if (fault == NoFault) {
            fault = readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);
            %(memacc_code)s;
        }

        if (fault == NoFault) {
            %(op_wb)s;
        }

        return fault;
    }

}};

def template LoadInitiateAcc {{
Fault %(class_name)s::initiateAcc(ExecContext *xc, Trace::InstRecord *traceData) const
{
Addr EA;
Fault fault = NoFault;

        %(op_src_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if (fault == NoFault) {
            fault = initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
        }

        return fault;
    }

}};

def template LoadCompleteAcc {{
Fault %(class_name)s::completeAcc(PacketPtr pkt, ExecContext *xc, Trace::InstRecord *traceData) const
{
Fault fault = NoFault;

        %(op_decl)s;
        %(op_rd)s;

        getMemLE(pkt, Mem, traceData);

        if (fault == NoFault) {
            %(memacc_code)s;
        }

        if (fault == NoFault) {
            %(op_wb)s;
        }

        return fault;
    }

}};</code></pre>

    <p>
      **Generated**
    </p>

    <pre class="wp-block-code"><code>Fault Add::execute(ExecContext *xc,
                   Trace::InstRecord *traceData) const {

Fault fault = NoFault;

uint64_t Rd = 0;
int64_t Rs1 = 0;
int64_t Rs2 = 0;
;
Rs1 = xc->readIntRegOperand(this, 0);
Rs2 = xc->readIntRegOperand(this, 1);
;
if (fault == NoFault) {
Rd = Rs1 + Rs2;
;
if (fault == NoFault) {
{
uint64_t final_val = Rd;
xc->setIntRegOperand(this, 0, final_val);

        if (traceData) {

Fault Lb::execute(ExecContext *xc, Trace::InstRecord *traceData) const {
Addr EA;
Fault fault = NoFault;

int64_t Rd = 0;
uint64_t Rs1 = 0;
int8_t Mem;

Rs1 = xc->readIntRegOperand(this, 0);

EA = Rs1 + offset;

if (fault == NoFault) {
fault = readMemAtomicLE(xc, traceData, EA, Mem, memAccessFlags);

    Rd = Mem;

}

if (fault == NoFault) {
{
int64_t final_val = Rd;
xc->setIntRegOperand(this, 0, final_val);

      if (traceData) {
        traceData->setData(final_val);
      }
    }

}

return fault;
}

Fault Lb::initiateAcc(ExecContext *xc, Trace::InstRecord *traceData) const {
Addr EA;
Fault fault = NoFault;

uint64_t Rs1 = 0;
int8_t Mem;

Rs1 = xc->readIntRegOperand(this, 0);

EA = Rs1 + offset;

if (fault == NoFault) {
fault = initiateMemRead(xc, traceData, EA, Mem, memAccessFlags);
}

return fault;
}

Fault Lb::completeAcc(PacketPtr pkt, ExecContext *xc, ::InstRecord *traceData) const {
Fault fault = NoFault;

int64_t Rd = 0;
int8_t Mem;

getMemLE(pkt, Mem, traceData);

if (fault == NoFault) {
Rd = Mem;
}

if (fault == NoFault) {
{
int64_t final_val = Rd;
xc->setIntRegOperand(this, 0, final_val);

      if (traceData) {
        traceData->setData(final_val);
      }
    };

}

return fault;
}</code></pre>

  </div>
</div></div>

### 3.2.6 Bitfield Operators

<div class="wp-block-jetpack-markdown">
  <p>
    According to the ISA Parser documentation, we can perform bitfield extraction on rvalues using the <:> syntax (inclusive). The colon has to be present even if we are extracting one bit.
  </p>
</div>

### 3.2.7 Operand Type Qualifiers

In order to generate correctly typed C++ execution code, operand types have to be specified with the following format:

<pre class="wp-block-code"><code>def operand_types {{
    'sb': 'int8_t',
    'ub': 'uint8_t',
    'sw': 'int16_t',
    'uw': 'uint16_t',
    'sl': 'int32_t',
    'ul': 'uint32_t',
    'sq': 'int64_t',
    'uq': 'uint64_t',
    'sf': 'float',
    'df': 'double',
}}</code></pre>

With operand types specified, we can write the code mnemonic as follows:

<pre class="wp-block-code">`Rc.sl = Ra.sl + Rb.sl;`</pre>

However, a better way to do it is to define instruction operands.

### 3.2.8 Instruction Operands

<div class="wp-block-jetpack-markdown">
  <p>
    We can define a list of recognized instruction operands and their characteristics via the `def operand` statement. Each element of the statement is a Python `dict` that maps operand strings to a 5-element `tuple`. The elements include:
  </p>
</div>

<div class="wp-block-jetpack-markdown">
  <ul>
    <li>
      operand class: `IntReg`, `FloatReg`, `Mem` (i.e., memory location), `NPC` or `ControlReg`
    </li>
    <li>
      default type of operand: an `operand_type`
    </li>
    <li>
      `bitfield` name: the `bitfield` corresponding to the register "index" (in the instruction's sense, not in the `ExecContext` sense, need to figure out how `ExecContext` manages the indexing)
    </li>
    <li>
      string or tuple <ul>
        <li>
          string: instruction flag unconditionally applied
        </li>
        <li>
          tuple: (<unconditional flag>, <flag when operand is source>, <flag when operand is destination>) => useful for memory references
        </li>
      </ul>
    </li>
    
    <li>
      sort priority: order of operands in disassembly
    </li>
  </ul>
</div>

An example of this is shown below (RISCV):

<pre class="wp-block-code"><code>def operands{{
#General Purpose Integer Reg Operands
  'Rd' : ('IntReg', 'ud', 'RD', 'IsInteger', 1),
  'Rs1' : ('IntReg', 'ud', 'RS1', 'IsInteger', 2),
  'Rs2' : ('IntReg', 'ud', 'RS2', 'IsInteger', 3),
  'Rt' : ('IntReg', 'ud', 'AMOTempReg', 'IsInteger', 4),
  'Rc1' : ('IntReg', 'ud', 'RC1', 'IsInteger', 2),
  'Rc2' : ('IntReg', 'ud', 'RC2', 'IsInteger', 3),
  'Rp1' : ('IntReg', 'ud', 'RP1 + 8', 'IsInteger', 2),
  'Rp2' : ('IntReg', 'ud', 'RP2 + 8', 'IsInteger', 3),
  'ra' : ('IntReg', 'ud', 'ReturnAddrReg', 'IsInteger', 1),
  'sp' : ('IntReg', 'ud', 'StackPointerReg', 'IsInteger', 2),

  'a0' : ('IntReg', 'ud', '10', 'IsInteger', 1),

  'Fd' : ('FloatReg', 'df', 'FD', 'IsFloating', 1),
  'Fd_bits' : ('FloatReg', 'ud', 'FD', 'IsFloating', 1),
  'Fs1' : ('FloatReg', 'df', 'FS1', 'IsFloating', 2),
  'Fs1_bits' : ('FloatReg', 'ud', 'FS1', 'IsFloating', 2),
  'Fs2' : ('FloatReg', 'df', 'FS2', 'IsFloating', 3),
  'Fs2_bits' : ('FloatReg', 'ud', 'FS2', 'IsFloating', 3),
  'Fs3' : ('FloatReg', 'df', 'FS3', 'IsFloating', 4),
  'Fs3_bits' : ('FloatReg', 'ud', 'FS3', 'IsFloating', 4),
  'Fc1' : ('FloatReg', 'df', 'FC1', 'IsFloating', 1),
  'Fc1_bits' : ('FloatReg', 'ud', 'FC1', 'IsFloating', 1),
  'Fc2' : ('FloatReg', 'df', 'FC2', 'IsFloatReg', 2),
  'Fc2_bits' : ('FloatReg', 'ud', 'FC2', 'IsFloating', 2),
  'Fp2' : ('FloatReg', 'df', 'FP2 + 8', 'IsFloating', 2),
  'Fp2_bits' : ('FloatReg', 'ud', 'FP2 + 8', 'IsFloating', 2),

#Memory Operand
  'Mem' : ('Mem', 'ud', None, ('IsMemRef', 'IsLoad', 'IsStore'), 5),

#Program Counter Operands
  'PC' : ('PCState', 'ud', 'pc', (None, None, 'IsControl'), 7),
  'NPC' : ('PCState', 'ud', 'npc', (None, None, 'IsControl'), 8),
}};</code></pre>

# 4 Summary

This tutorial / documentation is painstakingly put together over numerous days. I sincerely hope that it helps to explain the ISA Parser's inner workings despite the poor documentation on the official site. If there are any errors / gaps, please kindly comment such that I can rectify it. Thank you!
